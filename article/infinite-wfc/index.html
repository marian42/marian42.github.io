
<!doctype html>
<html class="no-js" lang="en">
    <head>
        <title>
            Generating an infinite world with the Wave Function Collapse algorithm | Marian's Blog
		</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="author" content="Marian Kleineberg">
        <meta name="description" content="Generating an infinite world with the Wave Function Collapse algorithm - Personal blog about game development, programming and making">
        <meta itemprop="name" content="Generating an infinite world with the Wave Function Collapse algorithm">
        <meta itemprop="description" content="Generating an infinite world with the Wave Function Collapse algorithm - Personal blog about game development, programming and making">
        <meta property="og:title" content="Generating an infinite world with the Wave Function Collapse algorithm">
        <meta property="og:description" content="Generating an infinite world with the Wave Function Collapse algorithm - Personal blog about game development, programming and making">
        <meta property="og:image" content="https://marian42.de/article/infinite-wfc/city_1280.jpg">
        <meta property="og:url" content="https://marian42.de/article/infinite-wfc/">
        <meta property="og:site_name" content="Marian's Blog"><meta property="og:type" content="website">

        <link rel="icon" type="image/png" href="https://marian42.de/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="https://marian42.de/favicon-16x16.png" sizes="16x16">

        <link href="https://marian42.de/index.xml" rel="feed" type="application/rss+xml" title="Marian's Blog" />
                
        <link rel="stylesheet" href="/style.css">        
    </head>
    <body>
        <header class="triangle-pattern">
            <div class="container">
                <a href="/" class="logo" alt="Marian's Blog">
                </a>
            </div>
        </header>
        
        <article class="card">
    <a href="/article/infinite-wfc/">
        <h1>Generating an infinite world with the Wave Function Collapse algorithm</h1>
    </a>
    <div class="timestamp">June 20, 2023</div>
    <div class="content">
        <p><figure>
    <a href="city.jpg">
        <img src="city_1280.jpg" alt="">
    </a>
</figure></p>
<p>This article describes how I generate an infinite city using the Wave Function Collapse algorithm in a way that is fast, deterministic, parallelizable and reliable.
It's a follow-up to <a href="/article/wfc/">my 2019 article</a> on adapting the WFC algorithm to generate an infinite world.
The new approach presented in this article removes the limitations of my original implementation.
I first mentioned these ideas in this <a href="https://twitter.com/marian42_/status/1490060483944140804">Twitter thread</a>.</p>
<h1>Objective</h1>
<p>The goal is to procedurally generate a 3D environment by placing human designed blocks on a 3D grid.
The blocks need to be placed in accordance with given adjacency contraints.
For each of the 6 sides of each block, some information about the face and its symmetry is used to generate a list of possible neighbors.</p>
<p><figure>
    <a href="modules.png">
        <img src="modules_1280.png" alt="">
    </a>
</figure></p>
<p>This is different from the original formulation of the <a href="https://github.com/mxgmn/WaveFunctionCollapse">WFC algorithm</a>, where the possible blocks, their adjacency rules and their spawn probabilities are extracted automatically from an example texture.</p>
<p>In this improved version, the generation method is robust enough to be shipped in a commercial game, so it needs to be reliable, fast and allow for artistic control over the result.</p>
<h1>Wave Function Collapse</h1>
<p>This article is aimed at readers who already know how the <a href="https://github.com/mxgmn/WaveFunctionCollapse">WFC algorithm</a> works, but here is a brief recap.
Remember, I'm skipping the part where blocks are extracted from an example texture and I'm only using the part where we generate a new &quot;texture&quot;.</p>
<p><figure>
    <a href="https://camo.githubusercontent.com/dc39c61e02aa67abd0f923628cf241120d14f517/687474703a2f2f692e696d6775722e636f6d2f734e75425653722e676966">
        <img src="https://camo.githubusercontent.com/dc39c61e02aa67abd0f923628cf241120d14f517/687474703a2f2f692e696d6775722e636f6d2f734e75425653722e676966" alt="">
    </a>
</figure><br />
(Gif by <a href="https://github.com/mxgmn">Maxim Gumin on Github</a>)</p>
<p>The algorithm starts with an array of slots (the &quot;wave function&quot;), where nothing is decided.
Each slot has a list of possible blocks (or &quot;modules&quot;) that can be placed there and in the starting state, each list contains all modules.
The algorithm will then do collapse steps and a constraint propagation steps until the map is fully collapsed or until it has reached a dead end.</p>
<h2>Collapse step</h2>
<p>We pick the slot with the lowest entropy and collapse it.
That means we pick one of the modules from that slot's list of possible modules and set it as the selected module for this slot.
Intuitively, the &quot;slot with the lowest entropy&quot; is the one with the least amount of choice.
If all modules have the same spawn probability, the slot with the fewest possible modules is the one with the lowest entropy.</p>
<h2>Constraint propagation</h2>
<p>Collapsing a slot effectively shrinks the list of possible modules of that slot to 1.
The constraint propagation step propagates this information through the map by removing modules from the respective lists of other slots that relied on a different choice for the slot we just collapsed.
The constraint propagation step of the WFC algorithm is the most compute intensive part.</p>
<h2>End</h2>
<p>The algorithm terminates when all slots are collapsed, which means success, or when the list of possible modules for any slot is empty.
In that case the procedure has failed and one could backtrack or start over.</p>
<h1>The original approach and its limitations</h1>
<p>(skip this section if you just want to know the solution)</p>
<p>WFC is usually applied to finite maps that can be stored in an array.
In my <a href="/article/wfc/">original post</a>, I described why I thought it would be impractical to do a chunk-based WFC implementation.
(I had not figured out how to avoid the problem that constraints need to be propagated across chunk boundaries)
Instead, I stored the map in a dictionary, where new slots would be allocated when they were needed or when they were touched by constraint propagation.
That means, even to geneate a small area of the map, a large cloud of slots around that area would be allocated since constraint propagation could &quot;bounce back&quot; into the area we're interested in.</p>
<p>Problems of that approach include:</p>
<p><strong>Non-determinism</strong>: The result of the generation depends on the order in which parts of the map are generated (and thus on the path the player takes).<br />
<strong>Memory leak</strong>: We can't release the memory used to generate a part of the world when the player leaves since we don't know at what point distant slots no longer have an effect on local world generation.<br />
<strong>Reliability</strong>: The longer you walk around, the higher the chance becomes that the WFC algorithm runs into a dead end and is unable to continue generating the map.<br />
<strong>Single threaded</strong>: Since there are no chunks, all operations on the map datastructure need to be sequential and can't run in multiple threads.
In practice, the map height had to be limited so that the map generation was fast enough.</p>
<p><figure>
    <a href="2018demo.jpg">
        <img src="2018demo_1280.jpg" alt="">
    </a>
</figure></p>
<p>My implementation of this flawed approach is still <a href="https://github.com/marian42/wavefunctioncollapse">available on Github</a> and a playable demo is on <a href="https://marian42.itch.io/wfc">itch.io</a>.
If you want to implement your own WFC algorithm, you shouldn't do it like that though!</p>
<h1>Chunk-based WFC</h1>
<p>The idea is to start with a simple pre-generated, tiling map and generate &quot;fitting&quot; replacements at runtime.
However, we do this at an offset so that the seam (which would otherwise look the same for each chunk) is replaced.
In this section, I'll explain in detail what that means.</p>
<p>This solution is a refinement of ideas proposed by <a href="https://paulmerrell.org/model-synthesis/">Paul Merrel</a> and <a href="https://www.boristhebrave.com/2021/11/08/infinite-modifying-in-blocks/">BorisTheBrave</a>.</p>
<p>We start by generating a simple, finite, tiling, 8x8x8 map:</p>
<p><figure>
    <a href="tilingmap.jpg">
        <img src="tilingmap_1280.jpg" alt="">
    </a>
</figure></p>
<p>This is done offline.
We use a small subset of the available modules to make it as simple as possible.
The map is <em>tiling</em> in the sense that the boundaries on opposite sides match, so copies of this map could be placed next to each other seamlessly.
Doing that would look like this:</p>
<p><figure>
    <a href="tilingworld.jpg">
        <img src="tilingworld_1280.jpg" alt="">
    </a>
</figure></p>
<p>Generating a tiling map is done by &quot;wrapping around&quot; the constraint propagation at the map boundary.
In a finite map, when we propagate a constraint to a slot outside the map, we discard that information.
In a tiling map, the slot on the opposing map boundary is treated as if it was a neighbor.</p>
<p>Next, we pre-generate a set of replacements for our starting map.</p>
<p><figure>
    <a href="patches.jpg">
        <img src="patches_1280.jpg" alt="">
    </a>
</figure></p>
<p>We use the boundary of the starting map as a boundary constraint to generate these replacements.
For any slots on the boundary of these new maps, we only allow modules with a matching profile for those sides that face the map boundary.
This means that we can &quot;swap out&quot; our starting map with any of the pre-generated patches without creating a visible seam.</p>
<p>Now we can randomly choose from our collection of pre-generated patches at runtime and we have a simple chunk-based infinite world generator:</p>
<p><figure>
    <a href="simplechunks.jpg">
        <img src="simplechunks_1280.jpg" alt="">
    </a>
</figure></p>
<p>Note that we're not doing any WFC generation at runtime yet, we're just placing pre-generated 8x8x8 block patches.
Since all these patches have a matching boundary, we can spot this chunk boundary as an unnatural pattern in the generated world.</p>
<p>Now for the important part:
At runtime, we generate an 8x8x8 replacement map for each chunk, <strong>but we do it at a 4 block offset in both horizontal directions</strong>.
The starting point for each chunks's generation is made up of the four pre-generated patches that touch it.
The replacement map we generate at runtime has a boundary constraint to &quot;fit in&quot;, just like our pre-generated patches.
However, due to the offset, the boundary that is shared between all pre-generated patches is replaced at runtime and the area that is different in every pre-generated patch remains unchanged during the runtime generation.
(This is needed so that neighbor chunks can be generated independently from each other.)
If this replacement map fails to generate, we just copy the blocks from the starting patches.</p>
<p>Here is the result of that:</p>
<p><figure>
    <a href="chunkwfc.jpg">
        <img src="chunkwfc_1280.jpg" alt="">
    </a>
</figure></p>
<p>Notice how the chunk boundary artifacts from the previous screenshot are gone!</p>
<p><figure>
    <a href="offset.png">
        <img src="offset_1280.png" alt="">
    </a>
</figure></p>
<p>Consider this drawing, where the gray blocks are one chunk (seen from above).
We determine the four starting patches that overlap this chunk (the blue boxes).
This needs to be random but deterministic, since neighbor chunks will need to use the same information.
We query the pre-generated patches at the boundary of the chunk (shown in green) and use this as the boundary constraint for the generation of the chunk.</p>
<p>The green boundary area will stay the same during runtime generation, but this looks ok due to the variance in the pre-generated patches.
The blue boundary is the same for each pre-generated patch, but will be replaced at runtime.</p>
<p>Note how this has the properties we want:
Each chunk can be generated deterministically and independently from other chunks.
If the generation for one chunk fails, we simply copy the blocks from the starting patches.</p>
<h1>Using a heightmap</h1>
<p>In this section, I'll explain how to generate a world in the shape of an arbitrary heightmap.</p>
<p>Consider an integer heightmap where the difference between two adjacent points is always one.
The next point is either one above or one below, but never at the same level or anywhere else.</p>
<p>Each 2x2 cell in that heightmap has one of these six shapes:</p>
<p><figure>
    <a href="shapes.png">
        <img src="shapes_1280.png" alt="">
    </a>
</figure></p>
<p>For each of these six possible 2x2 cell shapes, we pre-generate a set of starting patches:</p>
<p><figure>
    <a href="heightmappatches.jpg">
        <img src="heightmappatches_1280.jpg" alt="">
    </a>
</figure></p>
<p>These starting patches are no longer tiling in the classic sense.
Instead, each side matches the opposite side with a vertical offset.</p>
<p>With our special integer heightmap where adjacent points always have a difference of 1, we will now generate one chunk for each point in the heightmap.
Our query point has four adjacent 2x2 cells.
For each 2x2 cell, we determine which of the six possible shapes it has and pick a pre-generated starting patch from the respective collection.
Then, we generate a replacement map as explained in the previous section.</p>
<p>Here is an example of the heightmap in engine, each chunk is represented as one flat quad:</p>
<p><figure>
    <a href="heightmap.jpg">
        <img src="heightmap_1280.jpg" alt="">
    </a>
</figure></p>
<p>This mesh is used to render the world far away from the camera.
I added a &quot;city like&quot; texture and some billboard-rendered fake buildings.
In the foreground, you can see the actual chunks generated by the algorithm:</p>
<p><figure>
    <a href="heightmap2.jpg">
        <img src="heightmap2_1280.jpg" alt="">
    </a>
</figure></p>
<p>Okay, now we know how to turn our integer heightmap into a cool looking infinite WFC world, but how do we get that integer heightmap in the first place?
How do we get a function that generates an integer elevation function where the vertical difference between two adjacent points is always 1 or -1, but never 0 or anything else?</p>
<p>We start with a target function that doesn't have this property.
In my case, I'm using 8 octaves of Perlin noise, but any heightmap can be used here.</p>
<p>Then, we use an elaborate clamping process to force the step constraint on our target function.
It works in a hierarchical way, similarly to descending down a quadtree.
We start with a relatively large square (the root of the quadtree) and evaluate our target function for the four corners.
Then, we generate the heightmap value on the edge centers and the square center by querying the target function and then clamping the value to fulfil our slope constraint.
The slope constraint requires that the vertical difference is less than or equal the horizontal difference.
If our query point is inside any of the four quadrants, we repeat this process for the respective quadrant (descending the quadtree).
If our query point is one of the points we just calculated, we're done.</p>
<p>The hierarchical nature of this approach means that it lends itself very well to caching.</p>
<p>Here is a 2D visualization of the process:</p>
<p><figure>
    <a href="heightmapquery.png">
        <img src="heightmapquery_1280.png" alt="">
    </a>
</figure></p>
<p>The blue line shows the target function.
At every descend step down the quadtree, new limits are introduced to adhere to the slope constraint (shown as black lines).
The orange dots are the values of our resulting heightmap.</p>
<h1>Outlook and notes</h1>
<p>Each chunk can be generated independently.
That makes it easy to parallelize the computation required to generate the world.
In my case, I'm using Unity's Burst compiler to do the runtime generation.</p>
<p>By varying the module probabilities for different areas of the map, I can generate different biomes.
Here is an example of a biome boundary:</p>
<p><figure>
    <a href="biomeboundary.jpg">
        <img src="biomeboundary_1280.jpg" alt="">
    </a>
</figure></p>
<p>The biome on the left spawns copper roofs and bridges, the one on the right spawns tiled roofs and arches.
On the boundary, there is one row of chunks where modules from both biomes can spawn, creating a natural looking transition.</p>
<p>I want to mention some progress on this project that is unrelated to the WFC algorithm.
Since my last blog post in 2019, I've created lots of new blocks, textured them, added a water plane and added procedurally generated trees and climbing plants.</p>
<p><figure>
    <a href="plants.jpg">
        <img src="plants_1280.jpg" alt="">
    </a>
</figure></p>
<p>The trees and plants are generated at runtime using the Space Colonization algorithm and adapt to the geometry of the world.</p>
<p>The next challenge is to come up with interesting gameplay ideas for this project.</p>

    </div>
</article>

        <footer>
            <div class="socials">
                <div class="inner-div">
                    <a href="mailto:mail@marian42.de">
                        Contact
                    </a>
                </div>
                <div>
                    <a href="https://mastodon.gamedev.place/@marian42" rel="me" title="Follow me on Mastodon" class="social-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="-32 0 512 512">                                
                            <path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/>
                        </svg>
                    </a>
                    <a href="https://twitter.com/marian42_" title="Follow me on Twitter" class="social-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 248 204">
                            <path d="M221.95,51.29c0.15,2.17,0.15,4.34,0.15,6.53c0,66.73-50.8,143.69-143.69,143.69v-0.04 C50.97,201.51,24.1,193.65,1,178.83c3.99,0.48,8,0.72,12.02,0.73c22.74,0.02,44.83-7.61,62.72-21.66 c-21.61-0.41-40.56-14.5-47.18-35.07c7.57,1.46,15.37,1.16,22.8-0.87C27.8,117.2,10.85,96.5,10.85,72.46c0-0.22,0-0.43,0-0.64 c7.02,3.91,14.88,6.08,22.92,6.32C11.58,63.31,4.74,33.79,18.14,10.71c25.64,31.55,63.47,50.73,104.08,52.76 c-4.07-17.54,1.49-35.92,14.61-48.25c20.34-19.12,52.33-18.14,71.45,2.19c11.31-2.23,22.15-6.38,32.07-12.26 c-3.77,11.69-11.66,21.62-22.2,27.93c10.01-1.18,19.79-3.86,29-7.95C240.37,35.29,231.83,44.14,221.95,51.29z"/>
                        </svg>
                    </a>
                    <a href="https://github.com/marian42" title="View my code on Github" class="social-icon">
                        <svg viewbox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"/>
                        </svg>
                    </a>
                    <a href="/index.xml" title="RSS feed" class="social-icon">
                        <svg viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg">
                            <path d="M 0.38705632,0.38705632 V 1.5913525 A 6.021594,6.021594 0 0 1 6.4086474,7.6129437 H 7.6129437 A 7.2259129,7.2259129 0 0 0 0.38705632,0.38705632 Z m 0,2.40864748 V 4 A 3.6129564,3.6129564 0 0 1 4,7.6129437 H 5.2042963 A 4.8172751,4.8172751 0 0 0 0.38705632,2.7957038 Z M 1.3430849,5.7008865 A 0.95602666,0.95602666 0 0 0 0.38705632,6.6569151 0.95602666,0.95602666 0 0 0 1.3430849,7.6129437 0.95602666,0.95602666 0 0 0 2.2991135,6.6569151 0.95602666,0.95602666 0 0 0 1.3430849,5.7008865 Z" />
                        </svg>
                    </a>
                </div>
            </div>
            <div class="decorator triangle-pattern">
            </div>
        </footer>
    </body>
</html>